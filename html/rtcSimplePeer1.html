<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPClient1</title>
  <script src="./js/simplepeer.min.js"></script>
</head>

<body>
  <style>
    #outgoing {
      width: 600px;
      word-wrap: break-word;
      white-space: normal;
    }
  </style>
  <form>
    <input type="text" id="username" value="User1">
    <input type="password" id="userpass" value="123456" autocomplete="">
    <button id="btgo" type="button">connect</button>
  </form>
  <button id="sockSend" type="button" onclick="sockSend();">Send to peer</button>
  <pre id="outgoing"></pre>
  <script>
    var p = null
    var myPeers = {}

    async function sigConnect(target, userid, passhash) {
      if (myPeers[target]) {
        myPeers[target].close()
        myPeers[target].null
      }
      let srvSocket
      try {
        srvSocket = new WebSocket(`ws://localhost:3456?userid=${userid}&target=${target}&passhash=${passhash}`)
        //console.log(srvSocket);
      } catch (error) {
        console.log(error);
      }

      srvSocket.onopen = function (event) {
        console.log("Connected to signaller.");
        //srvSocket.send(JSON.stringify({ action: "activate", userid: userid, passhash: passhash }))
      };

      srvSocket.onmessage = function (msg) {
        let data = JSON.parse(msg.data)
        //console.log(data);
        switch (data.action) {
          case "access":
            if (data.status) {
              p = new SimplePeer({
                initiator: true,
                trickle: false
              })

              p.on('signal', data => {
                //console.log(data);
                data.userid = userid
                data.passhash = passhash
                data.target = target
                document.querySelector('#outgoing').textContent = JSON.stringify(data)
                setTimeout(() => {
                  srvSocket.send(JSON.stringify({ action: "offer", offer: data }))
                }, 200);
              })

              document.querySelector('form').addEventListener('submit', ev => {
                ev.preventDefault()
                p.signal(JSON.parse(document.querySelector('#incoming').value))
              })

              p.on('connect', () => {
                console.log('Connect to peer ' + target)
              })

              p.on('data', msg => {
                let data = JSON.parse(msg)
                console.log(data)
              })

              p.on('close', () => {
                console.log("peer closed", target);
                //myPeers[target].null
              })

              p.on('error', err => {
                console.log('error', err)
                myPeers[target].null
              })
            }
            break;
          case "answer":
            myPeers[data.userid] = p
            p.signal(data.answer)
            setTimeout(() => srvSocket.close(), 200);
            break;

          case "offline":
            console.log(data.peer + " is offline or do not exist.");
            srvSocket.close()
            break

          default:
            break;
        }
      };

      srvSocket.onclose = function (e) {
        console.log("Sig sock closed");
        //console.log(e);
      }
    }

    function sockSend() {
      if (p) {
        p.send(JSON.stringify({ id: Date.now(), action: "msg", text: "OlÃ¡!" }))
      } else {
        console.log("peer offline.");
      }
    }

    document.getElementById("btgo").onclick = async () => {
      //data.userid = document.getElementById("username").value
      //data.passhash = document.getElementById("userpass").value
      let user = document.getElementById("username").value
      let hash = await sha256(document.getElementById("userpass").value)
      sigConnect("Server1", user, hash)

      //return
      //console.log(srvSocket);

    }

    async function sha256(message) {
      // encode as UTF-8
      const msgBuffer = new TextEncoder().encode(message);

      // hash the message
      const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);

      // convert ArrayBuffer to Array
      const hashArray = Array.from(new Uint8Array(hashBuffer));

      // convert bytes to hex string
      const hashHex = hashArray.map(b => ('00' + b.toString(16)).slice(-2)).join('');
      //console.log(hashHex);
      return hashHex;
    }


  </script>
</body>

</html>